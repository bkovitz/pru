\documentclass[letterpaper,11pt,fleqn]{article}

\usepackage{listings}
\lstset{basicstyle=\footnotesize\ttfamily}

\usepackage{enumitem}
\usepackage{tabulary}
\usepackage{multirow}
\usepackage{siunitx}

\usepackage{hyperref}
\usepackage{url}
\urlstyle{sf}

\newcommand{\techref}{\textit{AM335x Technical Reference}}

\newenvironment{docref}
   {\vspace{\baselineskip}\noindent\begin{minipage}{\textwidth}\raggedright}
   {\end{minipage}}

\title{Real-Time Programming with the PRU \\ on the Beaglebone}
\author{Ben Kovitz}
\date{September 2015}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

This document shows you how to use the the PRU (Programmable Real-time Unit)
of the AM3358 Sitara processor on a BeagleBone Black to do real-time
programming.

The example code in this document generates and captures PWM (Pulse-Width
Modulation): one PRU generates pulses while the other PRU captures pulses.
Code running concurrently on the ARM processor sets outgoing pulse widths and
reads measurements of incoming pulse widths through memory shared with the
PRU.  This is probably not the best way to do PWM on an AM3358: the AM3358 has
a built-in PWM unit just for this kind of task, so the PRU really isn't
necessary. However, using the PRU to perform PWM does illustrate real-time
programming on a very simple but highly timing-sensitive example. It should be
straightforward to modify the examples presented here to make the PRU perform
tasks with hard real-time constraints of about 24~MHz while the ARM runs Linux
concurrently.

The complete example code can be downloaded from
\url{https://github.com/bkovitz/pru}. \label{sec-repo}
This document includes only code
snippets and explanations of principles and techniques that are either
fundamental or hard to piece together from the documentation. The Github
repository also contains \texttt{seegps.c}, which illustrates how to access
GPS data on the BeagleBone.

\subsection{Must-have documentation}

These are the authoritative manuals from Texas Instruments:

\nopagebreak
\begin{docref}
\textit{AM335x Technical Reference Manual} \\
\url{http://www.ti.com/lit/ug/spruh73l/spruh73l.pdf} \\
4,972 pages, including all memory maps, but it still doesn't explain everything.
\end{docref}

\begin{docref}
\textit{AM335x PRU-ICSS Reference Guide} \\
\url{https://github.com/beagleboard/am335x\_pru\_package/blob/master/am335xPruReferenceGuide.pdf} \\
Includes complete documentation of the PRU instruction set.
\end{docref}

\begin{docref}
\textit{PRU Assembly Instructions} \\
\url{http://processors.wiki.ti.com/index.php/PRU\_Assembly\_Instructions} \\
A more-convenient description of the PRU instruction set.
\end{docref}

\begin{docref}
\textit{PRU Linux Application Loader API Guide} \\
\url{http://processors.wiki.ti.com/index.php/PRU\_Linux\_Application\_Loader\_API\_Guide} \\
The C API for loading programs into PRU memory, enabling and disabling the
PRUs, etc.
\end{docref}

\vspace{\baselineskip}
\noindent
For hooking up hardware, you'll also need BeagleBoard's
documentation:

\begin{docref}
\textit{BeagleBone Rev A6 System Reference Manual} \\
\url{http://beagleboard.org/static/beaglebone/latest/Docs/Hardware/BONE\_SRM.pdf}
\end{docref}

\vspace{\baselineskip}
\noindent
The pinouts of the P8 and P9 expansion boards are explained on pp.~54--63.
Convenient spreadsheet forms of the pinouts are here:
\url{http://www.embedded-things.com/bbb/beaglebone-black-pin-mux-spreadsheet/}.

\subsection{PRU background}

The PRU is itself a microprocessor with a relatively simple instruction set.
The AM335x contains two PRUs in addition to an ARM Cortex-A8 microprocessor.
Each PRU has 32 registers, each 32 bits wide, and each instruction is 32 bits
wide.

The PRU runs at 200~MHz, has four buses, and no pipeline. Most
instructions take only one clock cycle despite the lack of a pipeline. Since
there is no pipeline, calculating the time required to execute PRU code is
often as simple as counting the instructions and multiplying by
\SI{5}{\nano\second}. The PRU even has a single-clock-cycle integer multiply
instruction.

The AM335x has four memory spaces:

{
\renewcommand{\arraystretch}{1.5}
\small
\nopagebreak
\vspace{\baselineskip}
\begin{tabulary}{\dimexpr\textwidth-\parindent\relax}{LLLJ}
level & address space & min. latency & \\
\hline
L1~\begin{minipage}[t]{1.5in}Instruction \& \\ Data Cache\end{minipage}
& 32K & single-cycle & Includes PRU instructions and scratchpad registers. \\
L2 Cache & 256K & \SI{8}{\nano\second}, \SI{20}{\nano\second} if cache miss
& Includes ARM/PRU shared memory. \\
L3 & Full 32-bit addressing & \SI{40}{\nano\second} & Access to DDR memory. \\
L4 & Full 32-bit addressing & $>$\SI{40}{\nano\second}? & Access to peripherals and GPIO ports. \\
\end{tabulary}
}

\vspace{\baselineskip}
As long as a PRU instruction is accessing L1 memory, it can read the
instruction, read the data, and write the result in a single clock cycle.
Accessing L2 memory introduces a delay of two to five clock cycles
plus additional uncertainty due to possible contention with the ARM. L3 and L4
introduce delays of at least 8 clock cycles and additional nondeterminism
because of possible contention with other devices on the AM335x.

% I never found a completely authoritative source for the above numbers. BEN 

Fortunately, the PRU provides ways to reduce or avoid accesses to memory
beyond L1. The scratchpad registers R0--R29 can be loaded at the start of a
program and serve as memory; PRU registers can even perform indirection,
providing the ``address'' of an operand stored in another register.
Bits in registers R30 and R31 of the PRU can be configured for direct
access to GPIO bits, reducing access time to a single PRU clock cycle. (See
section~4.4.1.2.3 of the \techref.)
The PRU has a set of hard-coded ``constant'' registers, C0--C31, which hold
frequently used addresses so these need not occupy the scratchpad registers.
(See section~4.4.1.1 of the \techref.) Many addresses in the L2 and L3
spaces lead to the same memory, so the PRU can avoid latency by accessing them
through the L2 addresses. In particular, this is the best way for the PRU to
access shared memory for communicating with the ARM.

Each PRU has 8K of instruction memory, running from addresses  0x00000000 to
0x00001fff (as seen from the PRU). A PRU's instruction memory cannot be
written to while the PRU is executing instructions. Each PRU has 8K of data
RAM, also running from addresses 0x00000000 to 0x00001fff; each PRU sees the
other PRU's data RAM at 0x00002000 to 0x00003fff.

The PRU does not support interrupts. Interrupts would complicate real-time
processing and make response times unpredictable. Instead, the PRU must poll
sources of interrupts. The documentation still calls them ``interrupts'' and 
the PRU has an ``interrupt controller'' (INTC) to track and prioritize them.

There is no C compiler for the PRU. So, you must write all PRU code in
assembly language by hand. The assembler for the PRU is called \textit{pasm}.

Technically, the entire unit that contains both PRUs is called the PRUSS
(Programmable Real-Time Unit Subsystem) or \mbox{PRU-ICSS} (Programmable
Real-Time Unit and Industrial Communication Subsystem).

\subsection{Installing and compiling}

I compiled all the code in this document on the BeagleBone Black itself under
Debian~7. Running the following commands as the superuser on the BeagleBone
Black will install the necessary development tools:

\begin{lstlisting}{language=bash}
  # apt-get install gdb
  # apt-get install gpsd gpsd-clients python-gps libgps-dev
\end{lstlisting}

\noindent
(The second line is needed only to run \texttt{seegps.c}.)

Development tools for the PRU are available at
\url{git://github.com/beagleboard/am335x\_pru\_package.git}. This is already
included in the repository for this document (see section~\ref{sec-repo}).
You'll need to compile pasm and the \textit{prussdrv} \label{sec-prussdrv}
application-loader library and install the header files:

\begin{lstlisting}{language=bash}
  $ cd $PRUHOME/am335x_pru_package-master/pru_sw/app_loader/interface
  $ make CROSS_COMPILE=""
  $ sudo make CROSS_COMPILE="" install
  $ cd ../../utils/pasm_source
  $ ./linuxbuild
  $ sudo cp pasm /usr/bin
\end{lstlisting}

\section{Hooking up the hardware}

The main example program performs a PWM loopback test, generating pulses on
the GPIO1[28] pin and capturing them on the GPIO1[16] pin. To make this
connection, simply connect a jumper between pins 12 and 15 on the BeagleBone's
P9 header.

To run the \texttt{seegps} program, you'll also need to hook up a GPS receiver
to UART1 on the BeagleBone (\texttt{/dev/ttyO1}). For the LS23060, the
connections are:

\nopagebreak
\vspace{\baselineskip}
\begin{tabulary}{\dimexpr\textwidth-\parindent\relax}{LCL}
\multicolumn{2}{l}{LS23060 (GPS)} & BeagleBone pin \\
\hline
3.3V power & to & P9.3 \\
GND & to & P9.1 \\
DATA & to & P9.26 (uart1\_rxd)
\end{tabulary}
\vspace{\baselineskip}

There's no need to transmit to the GPS device: it sends data continuously.

\section{Enabling the hardware}

Before program code on Linux on the BeagleBone can access the PRU and other
hardware, the drivers for tha hardware must be enabled. This is done most
easily through the \textit{sysfs} filesystem.

To enable the PRU (included in the \texttt{enable-pru01} shell script):

\begin{lstlisting}{language=bash}
  # echo BB-BONE-PRU-01 > /sys/devices/bone_capemgr.9/slots
  # modprobe uoi_pruss
\end{lstlisting}

To enable GPS over UART1 (included in the \texttt{enable-gps} shell script):

\begin{lstlisting}{language=bash}
  # echo BB-UART1 > /sys/devices/bone_capemgr.9/slots
  # stty -F /dev/ttyO1 57600
  # gpsd -n /dev/ttyO1
\end{lstlisting}

You may have to adjust the baud rate if you're using a GPS receiver other than
the LS23060.

\section{Setting up a PRU} \label{sec-setup}

\texttt{loopback.c} demonstrates everything involved in setting up a PRU from
C. All of the set-up involves the \textit{prussdrv} application-loader
library that you installed in section~\ref{sec-prussdrv}.

First, you must call \textit{prussdrv\_init} to initialize the library.
For each PRU interrupt event that you are going to work with, you must call
\textit{prussdrv\_open}, passing it \texttt{PRU\_EVTOUT\_0} or
\texttt{PRU\_EVTOUT\_1} depending on which event you will be setting up.
Even if you don't use interrupt events, you must call \textit{prussdrv\_open}
at least once.

To access a PRU's data RAM, you must call \textit{prussdrv\_map\_prumem}
and let it write the virtual address in your Linux process's memory
of the PRU data RAM. For example:

\begin{lstlisting}{language=C}
  prussdrv_map_prumem(PRUSS0_PRU0_DATARAM, (void**)&pru_delays);
\end{lstlisting}

\noindent
where \textit{pru\_delays} has been defined as follows:

\begin{lstlisting}{language=C}
typedef struct {
  unsigned int hi_delay;  // number of PRU loop iterations during pulse
  unsigned int lo_delay;  // number of PRU loop iterations between pulses
    // Each loop iteration takes 2 PRU clock cycles, or 10 ns.
} PRU_DELAYS;

PRU_DELAYS *pru_delays;     // Will point to PRU0 DATA RAM
\end{lstlisting}

Once you have the virtual address, you can initialize the PRU data RAM
by calling \textit{memset} or otherwise just writing directly to the memory.

To initialize the PRU's instruction RAM, call
\textit{prussdrv\_pru\_write\_memory} as illustrated here:

\begin{lstlisting}{language=C}
  if (prussdrv_pru_write_memory(
        PRUSS0_PRU0_IRAM, 0, (unsigned int *)pwm_bin, pwm_bin_len
     ) != pwm_bin_len / 4) {
    perror("prussdrv_pru_write_memory(PRU0)");
    return 1;
  }
\end{lstlisting}

\textit{pwm\_bin} is an array containing a binary image of the assembled PRU
machine code:

\begin{lstlisting}{language=C}
   extern unsigned char pwm_bin[];  // generated by xxd from pwm.p
   extern unsigned int pwm_bin_len;
\end{lstlisting}

The standard Linux utility \textit{xxd~-i} generates C source code defining
an array containing each byte in a given binary file. The Makefile in
\texttt{pru-pwm} demonstrates GNU Make pattern rules that automate converting
a \textit{.p} (\textit{pasm}) file into a \textit{.o} file suitable for
linking with code containing the above external declarations.

To enable blocking waits in C for a PRU to signal an event, you must enable
interrupts by calling \textit{prussdrv\_pruintc\_intc}:

\begin{lstlisting}{language=C}
  static tpruss_intc_initdata intc = PRUSS_INTC_INITDATA;
  if (prussdrv_pruintc_init(&intc) != 0) {
    perror("prussdrv_pruintc_init()");
    return 1;
  }
\end{lstlisting}

\noindent
\textit{intc} is a fairly complex struct that permits a great deal of
customization.  Fortunately, \textit{PRUSS\_INTC\_INITDATA} provides a set of
defaults that are correct for most uses.

To start a PRU executing, call \textit{prussdrv\_pru\_enable}:

\begin{lstlisting}{language=C}
  if (prussdrv_pru_enable(PRU0) != 0) {
    perror("prussdrv_pru_enable(0)");
    return 1;
  }
\end{lstlisting}

To stop the PRU, call \textit{prussdrv\_pru\_disable} with the same argument.

\section{Communicating with a running PRU}

The simplest way for a C program to communicate with a running PRU is to
read and write the PRU's data RAM. With \textit{pru\_delays} set up as
explained in section~\ref{sec-setup}, you can simply write to the data
structure that's laid out in the PRU's data RAM:

\begin{lstlisting}{language=C}
  pru_delays->hi_delay =
      (1000 + pulse_width) * CLOCKS_PER_uS / CLOCKS_PER_LOOP;
  pru_delays->lo_delay =
      (19000 - pulse_width) * CLOCKS_PER_uS / CLOCKS_PER_LOOP;
\end{lstlisting}

There is some danger that the PRU will read half-written data. I have not
found clear-cut documentation or an example on the Internet for a recommended
technique to prevent that. Roughly, the way to prevent out-of-sync writes to
PRU data RAM is to send the PRU an interrupt (an ``event'') and then clear the
event, and write PRU code to treat the event as a semaphore.

To read from PRU data RAM, \textit{prussdrv\_pru\_wait\_event} provides an
easy way to wait until the PRU signals that it has written new data. You can
simply make a \textit{pthread} that waits for the PRU event in an infinite
loop:

\begin{lstlisting}{language=C}
   void *measure_thread_func(void *arg) {
     do {
       prussdrv_pru_wait_event(PRU_EVTOUT_1);
       signed int start = pru_measure->start;
       signed int end =   pru_measure->end;
       // . . .
       prussdrv_pru_clear_event(PRU_EVTOUT_1, PRU1_ARM_INTERRUPT);
     } while (1);
   }
\end{lstlisting}

\section{GPS}

@@various stuff

\end{document}
