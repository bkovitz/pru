/*
 * BeagleBone loopback PWM test: measure pulse widths, generated and
 * measured by the PRU, conveyed to the ARM through threads that wait
 * for PRU events.
 *
 * Generates PWM wave with varying pulse widths at GPIO1[28] (P9.12) and
 * samples at GPIO1[16] (P9.15).
 *
 * Before running:
 *   The enable_pru01 script must have been run. It's only needed once per
 *   reboot of the Beaglebone, to enable access to the PRU.
 *
 * Usage:
 *   ./sudo loopback
 *
 * By Ben Kovitz, September 2015, starting from example PRU code by Douglas
 * Henke available at:
 *   https://github.com/beagleboard/am335x_pru_package
 * Much gratitude!
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include <prussdrv.h>
#include <pruss_intc_mapping.h>
#include "constants.h"

#define PRU0 0    // Generate pulses on PRU0
#define PRU1 1    // Sample pulses on PRU1

#define NUM_PULSES 200

extern unsigned char pwm_bin[];   // generated by xxd from pwm.p
extern unsigned int pwm_bin_len;
extern unsigned char measurep_bin[];
                                  // generated by xxd from measurep_bin.p
extern unsigned int measurep_bin_len;

#define CLOCKS_PER_uS 200 // clock cycles per microsecond (200 MHz PRU clock)
#define CLOCKS_PER_LOOP 2 // loop contains two instructions, one clock each

typedef struct {
  unsigned int hi_delay;  // number of PRU loop iterations during pulse
  unsigned int lo_delay;  // number of PRU loop iterations between pulses
    // Each loop iteration takes 2 PRU clock cycles, or 10 ns.
} PRU_DELAYS;

typedef struct {
  // Set by ARM, read by PRU:
  unsigned int gpio_base;   // base address of GPIO register
  unsigned char pin_bit;    // which pin to read (0..31)
  unsigned char pru_evtout; // which PRU_EVTOUT to signal after measuring pulse
  unsigned char ignored1;
  unsigned char ignored2;
  // Set by PRU, read by ARM:
  unsigned int start;   // start timestamp of last pulse measured
  unsigned int end;     // end timestamp of last pulse measured
                        // Timestamps increment at 40 MHz
} PRU_MEASURE;

PRU_DELAYS *pru_delays;     // Will point to PRU0 DATA RAM
PRU_MEASURE *pru_measure;   // Will point to PRU1 DATA RAM

void set_pulse_width(unsigned int pulse_width) {  // 0..1000 uS
   // Actual pulse width is 1 ms + pulse_width. Total PWM cycle time
   // is always 20 ms.
  pru_delays->hi_delay =
      (1000 + pulse_width) * CLOCKS_PER_uS / CLOCKS_PER_LOOP;
  pru_delays->lo_delay =
      (19000 - pulse_width) * CLOCKS_PER_uS / CLOCKS_PER_LOOP;
//  printf("hi_delay=%d lo_delay=%d\n",
//      pru_delays->hi_delay, pru_delays->lo_delay);
}

void sleep_millis(unsigned int millis) {  // milliseconds
   usleep(millis * 1000);
}

/*
 * Thread to watch PRU1 and print the length of each new pulse when PRU1
 * finishes measuring it.
 */

void *measure_thread_func(void *arg) {
  do {
    prussdrv_pru_wait_event(PRU_EVTOUT_1);
    signed int start = pru_measure->start;
    signed int end =   pru_measure->end;
    printf("pulse start=0x%08x end=0x%08x diff=%d time=%9.3f ms\n",
      start, end, end - start, 1000000.0 * (end - start) / 24000000.0);
    prussdrv_pru_clear_event(PRU_EVTOUT_1, PRU1_ARM_INTERRUPT);
  } while (1);
}

int main(int argc, char **argv) {
  if (geteuid()) {
    fprintf(stderr, "%s must be run as root\n", argv[0]);
    return 1;
  }

  if ((prussdrv_init()) != 0) {
    perror("prussdrv_init() failed");
    return 1;
  }

  if (prussdrv_open(PRU_EVTOUT_0) != 0) {
    perror("prussdrv_open(PRU_EVTOUT_0)");
    return 1;
  }

  if (prussdrv_open(PRU_EVTOUT_1) != 0) {
    perror("prussdrv_open(PRU_EVTOUT_1)");
    return 1;
  }

  /* map PRU DATA RAM */
  prussdrv_map_prumem(PRUSS0_PRU0_DATARAM, (void**)&pru_delays);
  prussdrv_map_prumem(PRUSS0_PRU1_DATARAM, (void**)&pru_measure);

  memset((void *)pru_measure, 0x99, sizeof(PRU_MEASURE));

  set_pulse_width(0);

  static tpruss_intc_initdata intc = PRUSS_INTC_INITDATA;
  if (prussdrv_pruintc_init(&intc) != 0) {
    perror("prussdrv_pruintc_init()");
    return 1;
  }

  if (prussdrv_pru_write_memory(
        PRUSS0_PRU0_IRAM, 0, (unsigned int *)pwm_bin, pwm_bin_len
     ) != pwm_bin_len / 4) {
    perror("prussdrv_pru_write_memory(PRU0)");
    return 1;
  }

  if (prussdrv_pru_write_memory(
        PRUSS0_PRU1_IRAM, 0, (unsigned int *)measurep_bin,
        measurep_bin_len
     ) != measurep_bin_len / 4) {
    perror("prussdrv_pru_write_memory(PRU1)");
    return 1;
  }

  pru_measure->gpio_base = GPIO1;
  pru_measure->pin_bit = 16;
  pru_measure->pru_evtout = PRU_EVTOUT_1_CODE;
  pru_measure->start = 99;
  pru_measure->end = 99;

  pthread_t measure_thread;
  int iret = pthread_create(&measure_thread, NULL, measure_thread_func, NULL);
  if (iret != 0) {
    perror("starting measure_thread");
    exit(1);
  }

  if (prussdrv_pru_enable(PRU0) != 0) {
    perror("prussdrv_pru_enable(0)");
    return 1;
  }

  if (prussdrv_pru_enable(PRU1) != 0) {
    perror("prussdrv_pru_enable(1)");
    return 1;
  }

  for (int i = 0; i < NUM_PULSES; i++) {
    set_pulse_width(i);
    sleep_millis(20);
  }
  set_pulse_width(0);

  prussdrv_pru_disable(PRU0);
  prussdrv_pru_disable(PRU1);
  prussdrv_exit();

  return 0;
}

