/*
 * BeagleBone timer test.
 *
 * Runs a timer and logs the contents of the TCRR (timer counter register)
 * 100 times in memory.
 *
 * RESULT:
 *   The BeagleBone already has DMTIMER2 running at top speed, with an
 *   interrupt to turn it over on overflow. In 1 sec, it counts
 *   approximately 24,200,000 ticks.
 *
 * Before running:
 *   The enable_pru01 script must have been run. It's only needed once per
 *   reboot of the Beaglebone, to enable access to the PRU.
 *
 * Usage:
 *   ./sudo loopback
 *
 * By Ben Kovitz, August 2015, starting from example PRU code by Douglas
 * Henke available at:
 *   https://github.com/beagleboard/am335x_pru_package
 * Much gratitude!
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <prussdrv.h>
#include <pruss_intc_mapping.h>

#define PRU0 0    // Generate pulses on PRU0
#define PRU1 1    // Sample pulses on PRU1

#define NUM_SAMPLES 100

extern unsigned char tcrr_bin[];   // generated by xxd from tcrr.p
extern unsigned int tcrr_bin_len;

unsigned int *pru1_data_ram;

void sleep_millis(unsigned int millis) {  // milliseconds
   const struct timespec sleep_time = { 0, millis * 1000000 };
   nanosleep(&sleep_time, NULL);
}

void run_pru(unsigned pru, unsigned evtout) {
  if (prussdrv_pru_enable(pru) != 0) {
    perror("prussdrv_pru_enable()");
    exit(1);
  }

  int pru_result1 = prussdrv_pru_wait_event(evtout);
  prussdrv_pru_clear_event(evtout, PRU1_ARM_INTERRUPT);

  printf("PRU%d program completed, event number %d\n", pru, pru_result1);

  for (int i = 0; i < 9; i++)
    printf("0x%08x\n", pru1_data_ram[i]);
}

int main(int argc, char **argv) {
  if (geteuid()) {
    fprintf(stderr, "%s must be run as root\n", argv[0]);
    return 1;
  }

  if ((prussdrv_init()) != 0) {
    perror("prussdrv_init() failed");
    return 1;
  }

  if (prussdrv_open(PRU_EVTOUT_1) != 0) {
    perror("prussdrv_open(PRU_EVTOUT_1)");
    return 1;
  }

  /* map PRU DATA RAM */
  prussdrv_map_prumem(PRUSS0_PRU1_DATARAM, (void**)&pru1_data_ram);

  for (int i = 0; i < NUM_SAMPLES; i++)
    pru1_data_ram[i] = 0;

  static tpruss_intc_initdata intc = PRUSS_INTC_INITDATA;
  if (prussdrv_pruintc_init(&intc) != 0) {
    perror("prussdrv_pruintc_init()");
    return 1;
  }

  if (prussdrv_pru_write_memory(
        PRUSS0_PRU1_IRAM, 0, (unsigned int *)tcrr_bin, tcrr_bin_len
     ) != tcrr_bin_len / 4) {
    perror("prussdrv_pru_write_memory(PRU1)");
    return 1;
  }

  run_pru(PRU1, PRU_EVTOUT_1);
  int first_count = pru1_data_ram[4];
  //sleep_millis(100);
  sleep(1);
  run_pru(PRU1, PRU_EVTOUT_1);
  int second_count = pru1_data_ram[4];
  printf("difference: %d\n", second_count - first_count);

  prussdrv_pru_disable(PRU1);
  prussdrv_exit();

  return 0;
}

